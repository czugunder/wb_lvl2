package listing3

import (
	"fmt"
	"os"
)

func Start() {
	mymain()
}

func Foo() error {
	var err *os.PathError = nil
	return err
}

func mymain() {
	err := Foo()
	fmt.Println(err)
	fmt.Println(err == nil)
}

// nil, false

// Под структурой os.PathError есть структура fs.PathError, для которой определены три метода,
// из всех них интересен Error() возвращающий string, что делает эту структуру удовлетворяющей интерфейсу error.
// В задаче: переменной c типом *fs.PathError в функции Foo был присвоен nil, но вернулся тип error со значением nil,
// так как Foo, возвращает *fs.PathError внутри интерфейса error.
// nil - потому что в переменную err типа error был возвращен nil.
// false - потому что только динамическое значение интерфейса имеет значение nil, но этот интерфейс имеет
// тип *fs.PathError, а значит не равен nil.

// Интерфейс описывает поведение структур. Под капотом имеет два указателя: один на экземпляр структуры, второй на
// т.н. таблицу интерфейса в которой хранятся метаданные и список методов для удовлетворения интерфейсу.
// Важная особенность - соответствие структуры интерфейсу определяется в runtime, а не на этапе компиляции.
// Пустой интерфейс не хранит таблицу интерфейса, так как он собственно ПУСТОЙ. Смысла в таком интерфейсе мало, так
// как он не определяет никакого поведения для структур. Единственное, что я могу предположить в качестве использования
// пустого интерфейса - это логика на основе типа данных, так как в пустой интерфейс можно закинуть переменную любого
// типа и потом уже этот тип детектировать и разветвлять логику.
